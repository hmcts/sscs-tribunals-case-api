#!groovy
properties([
        [$class: 'GithubProjectProperty', projectUrlStr: 'https://github.com/hmcts/tribunals-case-api'],
        pipelineTriggers([[$class: 'GitHubPushTrigger']])
])

@Library("Infrastructure")

import uk.gov.hmcts.contino.GradleBuilder
import uk.gov.hmcts.contino.Kubectl
import uk.gov.hmcts.contino.DockerImage

def type = "java"
def product = "sscs"
def component = "tribunals-api"

List<LinkedHashMap<String, Object>> secrets = [
  secret('idam-api', 'IDAM_API_URL'),
  secret('sscs-email-mac-secret-text', 'SUBSCRIPTIONS_MAC_SECRET'),
  secret('idam-oauth-user', 'IDAM_OAUTH2_CLIENT_ID'),
  secret('ccd-api', 'CORE_CASE_DATA_API_URL'),
  secret('ccd-jid', 'CORE_CASE_DATA_JURISDICTION_ID'),
  secret('ccd-tid', 'CORE_CASE_DATA_CASE_TYPE_ID'),
  secret('idam-redirect', 'IDAM_OAUTH2_REDIRECT_URL'),
  secret('idam-sscs-systemupdate-user', 'IDAM_SSCS_SYSTEMUPDATE_USER'),
  secret('idam-sscs-systemupdate-password', 'IDAM_SSCS_SYSTEMUPDATE_PASSWORD'),
  secret('idam-sscs-oauth2-client-secret', 'IDAM_OAUTH2_CLIENT_SECRET'),

  // Used by Kubernetes
  secret('idam-s2s-api', 'IDAM_S2S_AUTH'),
  secret('sscs-s2s-secret', 'IDAM_S2S_AUTH_TOTP_SECRET'),
  secret('s2s-micro', 'IDAM_S2S_AUTH_MICROSERVICE'),

  secret('idam-s2s-api', 'IDAM.S2S-AUTH'),
  secret('sscs-s2s-secret', 'IDAM.S2S-AUTH.TOTP_SECRET'),
  secret('s2s-micro', 'IDAM.S2S-AUTH.MICROSERVICE'),
]

static LinkedHashMap<String, Object> secret(String secretName, String envVar) {
  [ $class: 'AzureKeyVaultSecret',
    secretType: 'Secret',
    name: secretName,
    version: '',
    envVariable: envVar
  ]
}

withPipeline(type, product, component) {
  if (env.CHANGE_TITLE && !env.CHANGE_TITLE.startsWith('Bump')) {
    enableDockerBuild()
    enableDeployToAKS()
  }
  enableSlackNotifications('#sscs-tech')
  loadVaultSecrets(secrets)
  setVaultName('sscs')
  before('smoketest:aks') {
    withAksClient('nonprod') {
      env.RESOURCE_GROUP = 'sscs-tribunals-api-aks'
      def az = { cmd -> return sh(script: "env AZURE_CONFIG_DIR=/opt/jenkins/.azure-${env.SUBSCRIPTION_NAME} az $cmd", returnStdout: true).trim() }

      def dockerImage = new DockerImage(product, component, null, env.BRANCH_NAME)
      def subscription = env.SUBSCRIPTION_NAME
      def aksServiceName = dockerImage.getAksServiceName().toLowerCase()
      def storageSecret = "${aksServiceName}-storage-secret"
      def serviceBusSecret = "${aksServiceName}-servicebus-secret"
      def queueNames = [
        "envelopes",
        "notifications"
      ]
      def namespace = aksServiceName
      def kubectl = new Kubectl(this, subscription, namespace)
      kubectl.login()

      // Get service bus connection string and parse to get namespace
      def serviceBusConnectionStr = kubectl.getSecret(serviceBusSecret, namespace, "{.data.connectionString}")
      //Regex: Endpoint=sb:\/\/([-a-zA-Z0-9]+)\.servicebus\.windows\.net.*
      def serviceBusNamespace = serviceBusConnectionStr.substring(14).split("\\.")[0]

      // create queue
      def queues = az "servicebus queue list --resource-group ${env.RESOURCE_GROUP} --namespace-name ${serviceBusNamespace} --query '[].name'"
      queueNames.each {
        if (!queues.contains("${it}")) {
          az "servicebus queue create --resource-group ${env.RESOURCE_GROUP} --namespace-name ${serviceBusNamespace} --name ${it}"
        }
      }
    }
  }
}

