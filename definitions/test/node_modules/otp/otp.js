(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.otp = factory());
})(this, (function () { 'use strict';

  var sha1 = {exports: {}};

  var crypt = {exports: {}};

  (function() {
    var base64map
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

    crypt$1 = {
      // Bit-wise rotation left
      rotl: function(n, b) {
        return (n << b) | (n >>> (32 - b));
      },

      // Bit-wise rotation right
      rotr: function(n, b) {
        return (n << (32 - b)) | (n >>> b);
      },

      // Swap big-endian to little-endian and vice versa
      endian: function(n) {
        // If number given, swap endian
        if (n.constructor == Number) {
          return crypt$1.rotl(n, 8) & 0x00FF00FF | crypt$1.rotl(n, 24) & 0xFF00FF00;
        }

        // Else, assume array and swap all items
        for (var i = 0; i < n.length; i++)
          n[i] = crypt$1.endian(n[i]);
        return n;
      },

      // Generate an array of any length of random bytes
      randomBytes: function(n) {
        for (var bytes = []; n > 0; n--)
          bytes.push(Math.floor(Math.random() * 256));
        return bytes;
      },

      // Convert a byte array to big-endian 32-bit words
      bytesToWords: function(bytes) {
        for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
          words[b >>> 5] |= bytes[i] << (24 - b % 32);
        return words;
      },

      // Convert big-endian 32-bit words to a byte array
      wordsToBytes: function(words) {
        for (var bytes = [], b = 0; b < words.length * 32; b += 8)
          bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
        return bytes;
      },

      // Convert a byte array to a hex string
      bytesToHex: function(bytes) {
        for (var hex = [], i = 0; i < bytes.length; i++) {
          hex.push((bytes[i] >>> 4).toString(16));
          hex.push((bytes[i] & 0xF).toString(16));
        }
        return hex.join('');
      },

      // Convert a hex string to a byte array
      hexToBytes: function(hex) {
        for (var bytes = [], c = 0; c < hex.length; c += 2)
          bytes.push(parseInt(hex.substr(c, 2), 16));
        return bytes;
      },

      // Convert a byte array to a base-64 string
      bytesToBase64: function(bytes) {
        for (var base64 = [], i = 0; i < bytes.length; i += 3) {
          var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
          for (var j = 0; j < 4; j++)
            if (i * 8 + j * 6 <= bytes.length * 8)
              base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
            else
              base64.push('=');
        }
        return base64.join('');
      },

      // Convert a base-64 string to a byte array
      base64ToBytes: function(base64) {
        // Remove non-base-64 characters
        base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

        for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
            imod4 = ++i % 4) {
          if (imod4 == 0) continue;
          bytes.push(((base64map.indexOf(base64.charAt(i - 1))
              & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
              | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
        }
        return bytes;
      }
    };

    crypt.exports = crypt$1;
  })();

  var charenc = {
    // UTF-8 encoding
    utf8: {
      // Convert a string to a byte array
      stringToBytes: function(str) {
        return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
      },

      // Convert a byte array to a string
      bytesToString: function(bytes) {
        return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
      }
    },

    // Binary encoding
    bin: {
      // Convert a string to a byte array
      stringToBytes: function(str) {
        for (var bytes = [], i = 0; i < str.length; i++)
          bytes.push(str.charCodeAt(i) & 0xFF);
        return bytes;
      },

      // Convert a byte array to a string
      bytesToString: function(bytes) {
        for (var str = [], i = 0; i < bytes.length; i++)
          str.push(String.fromCharCode(bytes[i]));
        return str.join('');
      }
    }
  };

  var charenc_1 = charenc;

  (function() {
    var crypt$1 = crypt.exports,
        utf8 = charenc_1.utf8,
        bin = charenc_1.bin,

    // The core
    sha1$1 = function (message) {
      // Convert to byte array
      if (message.constructor == String)
        message = utf8.stringToBytes(message);
      else if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer == 'function' && Buffer.isBuffer(message))
        message = Array.prototype.slice.call(message, 0);
      else if (!Array.isArray(message))
        message = message.toString();

      // otherwise assume byte array

      var m  = crypt$1.bytesToWords(message),
          l  = message.length * 8,
          w  = [],
          H0 =  1732584193,
          H1 = -271733879,
          H2 = -1732584194,
          H3 =  271733878,
          H4 = -1009589776;

      // Padding
      m[l >> 5] |= 0x80 << (24 - l % 32);
      m[((l + 64 >>> 9) << 4) + 15] = l;

      for (var i = 0; i < m.length; i += 16) {
        var a = H0,
            b = H1,
            c = H2,
            d = H3,
            e = H4;

        for (var j = 0; j < 80; j++) {

          if (j < 16)
            w[j] = m[i + j];
          else {
            var n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
            w[j] = (n << 1) | (n >>> 31);
          }

          var t = ((H0 << 5) | (H0 >>> 27)) + H4 + (w[j] >>> 0) + (
                  j < 20 ? (H1 & H2 | ~H1 & H3) + 1518500249 :
                  j < 40 ? (H1 ^ H2 ^ H3) + 1859775393 :
                  j < 60 ? (H1 & H2 | H1 & H3 | H2 & H3) - 1894007588 :
                           (H1 ^ H2 ^ H3) - 899497514);

          H4 = H3;
          H3 = H2;
          H2 = (H1 << 30) | (H1 >>> 2);
          H1 = H0;
          H0 = t;
        }

        H0 += a;
        H1 += b;
        H2 += c;
        H3 += d;
        H4 += e;
      }

      return [H0, H1, H2, H3, H4];
    },

    // Public API
    api = function (message, options) {
      var digestbytes = crypt$1.wordsToBytes(sha1$1(message));
      return options && options.asBytes ? digestbytes :
          options && options.asString ? bin.bytesToString(digestbytes) :
          crypt$1.bytesToHex(digestbytes);
    };

    api._blocksize = 16;
    api._digestsize = 20;

    sha1.exports = api;
  })();

  const VOCAB = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ23456789='.split('');
  const PAD = ['=', '=', '=', '=', '=', '=', '=', '='];
  function encodeChunk(data) {
      const b1 = data.length > 0 ? data[0] : 0;
      const b2 = data.length > 1 ? data[1] : 0;
      const b3 = data.length > 2 ? data[2] : 0;
      const b4 = data.length > 3 ? data[3] : 0;
      const b5 = data.length > 4 ? data[4] : 0;
      const chars = [
          map(mask(b1 >> 3)), // [12345]678 >> 12345
          map(mask((b1 << 2) | (b2 >> 6))), // 12345678 << 67800 | 12345678 >> 00012
          map(mask(b2 >> 1)), // 12345678 >> 34567
          map(mask((b2 << 4) | (b3 >> 4))), // 12345678 << 80000 | 12345678 >> 01234
          map(mask((b3 << 1) | (b4 >> 7))), // 12345678 << 56780 | 12345678 >> 00001
          map(mask(b4 >> 2)), // 12345678 >> 23456
          map(mask((b4 << 3) | (b5 >> 5))), // 12345678 << 78000 | 12345678 >> 00123
          map(mask(b5)), // 12345678 >> 45678
      ];
      switch (data.length) {
          case 0:
              return '';
          case 1:
              return chars.slice(0, 2).concat(PAD).slice(0, 8).join('');
          case 2:
              return chars.slice(0, 4).concat(PAD).slice(0, 8).join('');
          case 3:
              return chars.slice(0, 5).concat(PAD).slice(0, 8).join('');
          case 4:
              return chars.slice(0, 7).concat(PAD).slice(0, 8).join('');
          case 5:
              return chars.slice(0, 8).concat(PAD).slice(0, 8).join('');
          default:
              return chars.join('');
      }
  }
  function mask(n) {
      return n & 0b00011111;
  }
  function map(n) {
      return n > -1 && n < VOCAB.length ? VOCAB[n] : '=';
  }
  function encode(data) {
      let offset = 0;
      const chunks = [];
      while (offset < data.length) {
          const subset = data.subarray(offset, offset + 5);
          chunks.push(encodeChunk(subset));
          offset += subset.length;
      }
      return chunks.join('');
  }
  function decodeChar(data) {
      const index = VOCAB.indexOf(data);
      if (index < 0)
          throw new Error('invalid character: ' + data);
      if (index === VOCAB.length - 1)
          return 0;
      return Math.max(index, 0);
  }
  function decodeChunk(data, dest) {
      const c1 = decodeChar(data[0]);
      const c2 = decodeChar(data[1]);
      const c3 = data[2] ? decodeChar(data[2]) : undefined;
      const c4 = data[3] ? decodeChar(data[3]) : undefined;
      const c5 = data[4] ? decodeChar(data[4]) : undefined;
      const c6 = data[5] ? decodeChar(data[5]) : undefined;
      const c7 = data[6] ? decodeChar(data[6]) : undefined;
      const c8 = data[7] ? decodeChar(data[7]) : undefined;
      dest[0] = byte((c1 << 3) | (c2 >> 2));
      if (defined(c3, c4))
          dest[1] = byte((c2 << 6) | (c3 << 1) | (c4 >> 4)); // xxx12 34567 8xxxx
      if (defined(c4, c5))
          dest[2] = byte((c4 << 4) | (c5 >> 1)); // x1234 1234x
      if (defined(c5, c6, c7))
          dest[3] = byte((c5 << 7) | (c6 << 2) | (c7 >> 3)); // xxxx1 23456 78xxx
      if (defined(c7, c8))
          dest[4] = byte((c7 << 5) | c8); // xx123 45678
  }
  function defined(...args) {
      for (const arg of args)
          if (arg === undefined)
              return false;
      return true;
  }
  function byte(n) {
      return n & 0xff;
  }
  function decode(data) {
      data = data
          .split(/\s+/)
          .map((s) => s.trim())
          .join('');
      const dest = new Uint8Array((data.length * 5) / 8);
      const chars = data.split('');
      let coff = 0;
      let boff = 0;
      let fin = 5;
      while (fin == 5 && coff < chars.length && boff < dest.length) {
          const chunk = chars.slice(coff, coff + 8);
          if (chunk.indexOf('=') > -1) {
              chunk.splice(chunk.indexOf('='), 8);
              switch (chunk.length) {
                  case 2:
                      fin = 1;
                      break;
                  case 4:
                      fin = 2;
                      break;
                  case 5:
                      fin = 3;
                      break;
                  case 7:
                      fin = 4;
                      break;
                  default:
                      throw new Error('invalid padding');
              }
          }
          decodeChunk(chunk, dest.subarray(boff, boff + 5));
          coff += 8;
          boff += 5;
      }
      return dest.subarray(0, dest.length - 5 + fin);
  }

  class OTP {
      constructor(options = {}) {
          if ('string' === typeof options)
              return OTP.parse(options);
          options = Object.assign({}, options);
          options.name = `${options.name || 'OTP-Authentication'}`.split(/[^\w|_|-|@]/).join('');
          options.keySize = options.keySize === 128 ? 128 : 64;
          options.codeLength = isNaN(options.codeLength) ? 6 : options.codeLength;
          options.secret = options.secret || generateKey(options.keySize);
          options.epoch = isNaN(options.epoch) ? 0 : options.epoch;
          options.timeSlice = isNaN(options.timeSlice) ? 30 : options.timeSlice;
          this.options = options;
          this.hotp = hotp.bind(null, options);
          this.totp = totp.bind(null, options);
      }
      get name() {
          return this.options.name;
      }
      get secret() {
          return this.options.secret;
      }
      get totpURL() {
          return `otpauth://totp/${encodeURIComponent(this.name)}?secret=${encodeURIComponent(this.secret)}`;
      }
      get hotpURL() {
          return `otpauth://hotp/${encodeURIComponent(this.name)}?secret=${encodeURIComponent(this.secret)}`;
      }
      toString() {
          return '[object OTP]';
      }
      toJSON() {
          return Object.assign({ class: OTP.classID }, this.options);
      }
      static reviveJSON(_, val) {
          if ('object' !== typeof val || null === val || val['class'] !== OTP.classID)
              return val;
          const { name, keySize, codeLength, secret, epoch, timeSlice } = val;
          return new OTP({ name, keySize, codeLength, secret, epoch, timeSlice });
      }
      static parse(urlstr = '', options = {}) {
          options = Object.assign({}, options);
          try {
              const url = new URL(urlstr);
              const name = decodeURIComponent(url.pathname.slice(1)).trim();
              const rawsecret = decode(decodeURIComponent(url.searchParams.get('secret')));
              const keySize = rawsecret.byteLength;
              const secret = encode(rawsecret);
              if (name)
                  options = Object.assign(options, name ? { name, keySize, secret } : { keySize, secret });
          }
          catch {
              const rawsecret = decode(urlstr);
              const keySize = rawsecret.byteLength;
              const secret = encode(rawsecret);
              options = Object.assign(options, { keySize, secret });
          }
          return new OTP(options);
      }
  }
  OTP.classID = 'OTP{@pipobscure}';
  function hotp(options, counter) {
      const digest = new Hmac(options.keySize, decode(options.secret)).update(UInt64Buffer(counter)).digest();
      const offset = digest[19] & 0xf;
      const code = String(((digest[offset] & 0x7f) << 24) |
          ((digest[offset + 1] & 0xff) << 16) |
          ((digest[offset + 2] & 0xff) << 8) |
          (digest[offset + 3] & 0xff));
      return `${new Array(options.codeLength).fill('0')}${code}`.slice(-1 * options.codeLength);
  }
  function totp(options, now = Date.now()) {
      const counter = Math.floor((now - options.epoch * 1000) / (options.timeSlice * 1000));
      return hotp(options, counter);
  }
  function generateKey(length) {
      const bytes = new Uint8Array(length);
      globalThis.crypto.getRandomValues(bytes);
      return encode(bytes);
  }
  function UInt64Buffer(num) {
      const buffer = new ArrayBuffer(8);
      new DataView(buffer).setBigUint64(0, BigInt(num));
      return new Uint8Array(buffer);
  }
  class Hmac {
      constructor(blocksize, key) {
          if (blocksize !== 128 && blocksize !== 64) {
              throw new Error('blocksize must be either 64 for or 128 , but was:' + blocksize);
          }
          this.key = rekey(key, blocksize);
          this.opad = new Uint8Array(new Array(blocksize).fill(0));
          this.ipad = new Uint8Array(new Array(blocksize).fill(0));
          for (var i = 0; i < blocksize; i++) {
              this.ipad[i] = this.key[i] ^ 0x36;
              this.opad[i] = this.key[i] ^ 0x5c;
          }
          this.hash = new Hash();
          this.hash.update(this.ipad);
      }
      update(data) {
          this.hash.update(data);
          return this;
      }
      digest() {
          const hash = this.hash.digest();
          return new Hash().update(this.opad).update(hash).digest();
      }
  }
  function rekey(key, blocksize) {
      if (key.length > blocksize) {
          return Hash.hash(key);
      }
      if (key.length < blocksize) {
          const res = new Uint8Array(blocksize);
          res.set(key);
          res.fill(0, key.length);
          return res;
      }
      return key;
  }
  class Hash {
      constructor() {
          this.data = [];
      }
      update(data) {
          this.data.push(...data.values());
          return this;
      }
      digest() {
          return sha1.exports(this.data, { asBytes: true });
      }
      static hash(data) {
          return new Hash().update(data).digest();
      }
  }

  return OTP;

}));
