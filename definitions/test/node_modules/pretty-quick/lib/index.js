"use strict";
const tslib_1 = require("tslib");
const createIgnorer_js_1 = tslib_1.__importDefault(require("./createIgnorer.js"));
const createMatcher_js_1 = tslib_1.__importDefault(require("./createMatcher.js"));
const isSupportedExtension_js_1 = tslib_1.__importDefault(require("./isSupportedExtension.js"));
const processFiles_js_1 = tslib_1.__importDefault(require("./processFiles.js"));
const index_js_1 = tslib_1.__importDefault(require("./scms/index.js"));
const utils_js_1 = require("./utils.js");
module.exports = async (currentDirectory, { config, since, staged, pattern, restage = true, branch, bail, check, ignorePath, verbose, onFoundSinceRevision, onFoundChangedFiles, onPartiallyStagedFile, onExamineFile, onCheckFile, onWriteFile, resolveConfig = true, } = {}) => {
    const scm = (0, index_js_1.default)(currentDirectory);
    if (!scm) {
        throw new Error('Unable to detect a source control manager.');
    }
    const directory = scm.rootDirectory;
    const revision = since || scm.getSinceRevision(directory, { staged, branch });
    onFoundSinceRevision?.(scm.name, revision);
    const rootIgnorer = (0, createIgnorer_js_1.default)(directory, ignorePath);
    const cwdIgnorer = currentDirectory === directory
        ? () => true
        : (0, createIgnorer_js_1.default)(currentDirectory, ignorePath);
    const patternMatcher = (0, createMatcher_js_1.default)(pattern);
    const isFileSupportedExtension = (0, isSupportedExtension_js_1.default)(resolveConfig);
    const changedFiles = await (0, utils_js_1.filterAsync)(scm
        .getChangedFiles(directory, revision, staged)
        .filter(patternMatcher)
        .filter(rootIgnorer)
        .filter(cwdIgnorer), isFileSupportedExtension);
    const unstagedFiles = staged
        ? await (0, utils_js_1.filterAsync)(scm
            .getUnstagedChangedFiles(directory)
            .filter(patternMatcher)
            .filter(rootIgnorer)
            .filter(cwdIgnorer), isFileSupportedExtension)
        : [];
    const wasFullyStaged = (file) => !unstagedFiles.includes(file);
    onFoundChangedFiles?.(changedFiles);
    const failReasons = new Set();
    await (0, processFiles_js_1.default)(directory, changedFiles, {
        check,
        config,
        onWriteFile(file) {
            onWriteFile?.(file);
            if (bail) {
                failReasons.add('BAIL_ON_WRITE');
            }
            if (staged && restage) {
                if (wasFullyStaged(file)) {
                    scm.stageFile(directory, file);
                }
                else {
                    onPartiallyStagedFile?.(file);
                    failReasons.add('PARTIALLY_STAGED_FILE');
                }
            }
        },
        onCheckFile: (file, isFormatted) => {
            onCheckFile?.(file, isFormatted);
            if (!isFormatted) {
                failReasons.add('CHECK_FAILED');
            }
        },
        onExamineFile: verbose ? onExamineFile : undefined,
    });
    return {
        success: failReasons.size === 0,
        errors: [...failReasons],
    };
};
//# sourceMappingURL=index.js.map